g_ai.cpp:	ent->r.client->ps.pmove.delta_angles[ 0 ] = 0;
g_ai.cpp:	ent->r.client->ps.pmove.delta_angles[ 1 ] = 0;
g_ai.cpp:	ent->r.client->ps.pmove.delta_angles[ 2 ] = 0;
g_ai.cpp:	ent->r.client->level.last_activity = level.time;
g_ai.cpp:	if( self->r.client->team == TEAM_SPECTATOR ) {
g_ai.cpp:		if( self->r.client->team == TEAM_SPECTATOR ) { // couldn't join, delay the next think
g_ai.cpp:	ucmd.angles[ 0 ] = (short)ANGLE2SHORT( self->s.angles.x ) - self->r.client->ps.pmove.delta_angles[ 0 ];
g_ai.cpp:	ucmd.angles[ 1 ] = (short)ANGLE2SHORT( self->s.angles.y ) - self->r.client->ps.pmove.delta_angles[ 1 ];
g_ai.cpp:	ucmd.angles[ 2 ] = (short)ANGLE2SHORT( self->s.angles.z ) - self->r.client->ps.pmove.delta_angles[ 2 ];
g_ai.cpp:	self->r.client->ps.pmove.delta_angles[ 0 ] = 0;
g_ai.cpp:	self->r.client->ps.pmove.delta_angles[ 1 ] = 0;
g_ai.cpp:	self->r.client->ps.pmove.delta_angles[ 2 ] = 0;
g_callvotes.cpp:		msg->append( "\n{}: {}", i, e->r.client->netname );
g_callvotes.cpp:						tokick->r.client->netname, S_COLOR_RED );
g_callvotes.cpp:	vote->string.format( "{}", game.edicts[who + 1].r.client->netname );
g_callvotes.cpp:	G_PrintMsg( NULL, "Player %s%s moved to spectators %s%s.\n", ent->r.client->netname, S_COLOR_WHITE,
g_callvotes.cpp:			if( game.edicts[who + 1].r.client->isoperator ) {
g_callvotes.cpp:				G_PrintMsg( vote->caller, S_COLOR_RED "%s is a game operator.\n", game.edicts[who + 1].r.client->netname );
g_callvotes.cpp:	vote->string.format( "{}", game.edicts[who + 1].r.client->netname );
g_callvotes.cpp:			if( game.edicts[who + 1].r.client->isoperator ) {
g_callvotes.cpp:				G_PrintMsg( vote->caller, S_COLOR_RED "%s is a game operator.\n", game.edicts[who + 1].r.client->netname );
g_callvotes.cpp:	vote->string.format( "{}", game.edicts[who + 1].r.client->netname );
g_callvotes.cpp:	Cbuf_Add( "addip {} {}", ent->r.client->ip, 15 );
g_callvotes.cpp:		callvoteState.vote.caller->r.client->level.callvote_when = svs.realtime;
g_callvotes.cpp:			bool inactive = client->level.last_activity + g_inactivity_maxtime->number * 1000 < level.time;
g_callvotes.cpp:	if( !isopcall && ent->r.client->level.callvote_when &&
g_callvotes.cpp:		( ent->r.client->level.callvote_when + callvoteCooldown > svs.realtime ) ) {
g_callvotes.cpp:	ent->r.client->level.callvote_when = callvoteState.timeout;
g_callvotes.cpp:				ent->r.client->netname, G_CallVotes_String( &callvoteState.vote ) );
g_callvotes.cpp:	if( !ent->r.client->isoperator ) {
g_callvotes.cpp:					forceVote == VOTED_NO ? "cancelled" : "passed", ent->r.client->netname );
g_callvotes.cpp:			G_PrintMsg( ent, "The player '%s' is already in team '%s'.\n", playerEnt->r.client->netname, GS_TeamName( newTeam ) );
g_callvotes.cpp:		G_PrintMsg( NULL, "%s was moved to team %s by %s.\n", playerEnt->r.client->netname, GS_TeamName( newTeam ), ent->r.client->netname );
g_chase.cpp:	ent->r.client->resp.chase.active = active;
g_chase.cpp:	if( !ent->r.client->resp.chase.active ) {
g_chase.cpp:	edict_t * targ = &game.edicts[ent->r.client->resp.chase.target];
g_chase.cpp:		if( svs.realtime < ent->r.client->resp.chase.timeout ) { // wait for timeout
g_chase.cpp:		targ = &game.edicts[ent->r.client->resp.chase.target];
g_chase.cpp:	ent->r.client->resp.chase.timeout = svs.realtime + 1500; // update timeout
g_chase.cpp:	bool ready = ent->r.client->ps.ready;
g_chase.cpp:	bool voted = ent->r.client->ps.voted;
g_chase.cpp:	ent->r.client->ps = targ->r.client->ps;
g_chase.cpp:	ent->r.client->ps.ready = ready;
g_chase.cpp:	ent->r.client->ps.voted = voted;
g_chase.cpp:	ent->r.client->ps.real_team = ent->s.team;
g_chase.cpp:	ent->r.client->ps.pmove.pm_type = PM_CHASECAM;
g_chase.cpp:	ent->r.client->ps.pmove.pm_flags |= PMF_NO_PREDICTION;
g_chase.cpp:		client->resp.chase.active = true;
g_chase.cpp:		client->resp.chase.target = ENTNUM( e );
g_chase.cpp:	client->resp.chase.active = false;
g_chase.cpp:	if( !ent->r.client->resp.chase.active ) {
g_chase.cpp:	int start = ent->r.client->resp.chase.target;
g_chase.cpp:		ent->r.client->resp.chase.target = ENTNUM( newtarget );
g_chase.cpp:			G_PrintMsg( NULL, "%s joined the %s team.\n", ent->r.client->netname, GS_TeamName( ent->s.team ) );
g_chase.cpp:		if( ent->r.client->resp.chase.active ) {
g_cmds.cpp:	if( ent->r.client->ps.pmove.pm_type != PM_SPECTATOR ) {
g_cmds.cpp:	ent->r.client->ps.pmove.pm_time = 1;
g_cmds.cpp:	ent->r.client->ps.pmove.pm_flags |= PMF_TIME_TELEPORT;
g_cmds.cpp:	if( ent->r.client->ps.pmove.pm_type != PM_SPECTATOR ) {
g_cmds.cpp:	ent->r.client->ps.viewangles = angles;
g_cmds.cpp:	ent->r.client->ps.pmove.delta_angles[ 0 ] = ANGLE2SHORT( ent->r.client->ps.viewangles.x ) - ent->r.client->ucmd.angles[ 0 ];
g_cmds.cpp:	ent->r.client->ps.pmove.delta_angles[ 1 ] = ANGLE2SHORT( ent->r.client->ps.viewangles.y ) - ent->r.client->ucmd.angles[ 1 ];
g_cmds.cpp:	ent->r.client->ps.pmove.delta_angles[ 2 ] = ANGLE2SHORT( ent->r.client->ps.viewangles.z ) - ent->r.client->ucmd.angles[ 2 ];
g_cmds.cpp:		if( !ent->r.client->isoperator ) {
g_cmds.cpp:			G_PrintMsg( NULL, "%s" S_COLOR_WHITE " is now a game operator\n", ent->r.client->netname );
g_cmds.cpp:		ent->r.client->isoperator = true;
g_cmds.cpp:		ent->r.client->ps.pmove.pm_type != PM_SPECTATOR ) {
g_cmds.cpp:	if( ent->r.client->teamstate.position_lastcmd + 500 > svs.realtime ) {
g_cmds.cpp:	ent->r.client->teamstate.position_lastcmd = svs.realtime;
g_cmds.cpp:		ent->r.client->teamstate.position_saved = true;
g_cmds.cpp:		ent->r.client->teamstate.position_origin = ent->s.origin;
g_cmds.cpp:		ent->r.client->teamstate.position_angles = ent->s.angles;
g_cmds.cpp:		if( !ent->r.client->teamstate.position_saved ) {
g_cmds.cpp:			if( G_Teleport( ent, ent->r.client->teamstate.position_origin, ent->r.client->teamstate.position_angles ) ) {
g_cmds.cpp:		if( svs.realtime < client->level.flood_locktill ) {
g_cmds.cpp:						(int)( ( client->level.flood_locktill - svs.realtime ) / 1000.0f ) + 1 );
g_cmds.cpp:			i = client->level.flood_team_whenhead - g_floodprotection_team->integer + 1;
g_cmds.cpp:			if( client->level.flood_team_when[i] && client->level.flood_team_when[i] <= svs.realtime &&
g_cmds.cpp:				( svs.realtime < client->level.flood_team_when[i] + g_floodprotection_seconds->integer * 1000 ) ) {
g_cmds.cpp:				client->level.flood_locktill = svs.realtime + g_floodprotection_penalty->integer * 1000;
g_cmds.cpp:		client->level.flood_team_whenhead = ( client->level.flood_team_whenhead + 1 ) % MAX_FLOOD_MESSAGES;
g_cmds.cpp:		client->level.flood_team_when[client->level.flood_team_whenhead] = svs.realtime;
g_cmds.cpp:			i = client->level.flood_whenhead - g_floodprotection_messages->integer + 1;
g_cmds.cpp:			if( client->level.flood_when[i] && client->level.flood_when[i] <= svs.realtime &&
g_cmds.cpp:				( svs.realtime < client->level.flood_when[i] + g_floodprotection_seconds->integer * 1000 ) ) {
g_cmds.cpp:				client->level.flood_locktill = svs.realtime + g_floodprotection_penalty->integer * 1000;
g_cmds.cpp:		client->level.flood_whenhead = ( client->level.flood_whenhead + 1 ) % MAX_FLOOD_MESSAGES;
g_cmds.cpp:		client->level.flood_when[client->level.flood_whenhead] = svs.realtime;
g_cmds.cpp:	if( ent->r.client->level.last_spray + 2500 > svs.realtime )
g_cmds.cpp:	AngleVectors( ent->r.client->ps.viewangles, &forward, NULL, NULL );
g_cmds.cpp:	Vec3 start = ent->s.origin + Vec3( 0.0f, 0.0f, ent->r.client->ps.viewheight );
g_cmds.cpp:	ent->r.client->level.last_spray = svs.realtime;
g_cmds.cpp:	event->s.angles = ent->r.client->ps.viewangles;
g_cmds.cpp:	if( ent->r.client->level.last_vsay > svs.realtime - 500 ) {
g_cmds.cpp:	ent->r.client->level.last_vsay = svs.realtime;
g_cmds.cpp:	G_PrintMsg( NULL, "%s%s called a timeout\n", ent->r.client->netname, S_COLOR_WHITE );
g_cmds.cpp:	G_PrintMsg( NULL, "%s%s called a timein\n", ent->r.client->netname, S_COLOR_WHITE );
g_combat.cpp:		targ->r.client->ps.pmove.knockback_time = Clamp( 100, 3 * knockback, 250 );
g_combat.cpp:		center_of_mass = origin + Vec3( 0.0f, 0.0f, r->client->ps.viewheight );
g_frame.cpp:	player->ping = ent->r.client->r.ping;
g_frame.cpp:	player->carrier = ent->r.client->ps.carrying_bomb;
g_frame.cpp:			memset( &ent->r.client->resp.snap, 0, sizeof( ent->r.client->resp.snap ) );
g_gametypes.cpp:	G_PrintMsg( NULL, "%s is %sREADY\n", ent->r.client->netname, S_COLOR_GREEN );
g_gametypes.cpp:	G_PrintMsg( NULL, "%s is %sNOT READY\n", ent->r.client->netname, S_COLOR_RED );
g_jumppad.cpp:		GS_TouchPushTrigger( &server_gs, &other->r.client->ps, &ent->s );
g_main.cpp:			ent->r.client->connecting = true; // set all connected players as "reconnecting"
g_phys.cpp:		pushed_p->pmove_origin = pusher->r.client->ps.pmove.velocity;
g_phys.cpp:		pushed_p->yaw = pusher->r.client->ps.viewangles.y;
g_phys.cpp:				check->r.client->ps.pmove.origin = check->r.client->ps.pmove.origin + move;
g_phys.cpp:				check->r.client->ps.viewangles.y += amove.y;
g_phys.cpp:				p->ent->r.client->ps.pmove.origin = p->pmove_origin;
g_phys.cpp:				p->ent->r.client->ps.viewangles.y = p->yaw;
g_teams.cpp:		result = Q_stricmp( edict_a->r.client->netname, edict_b->r.client->netname );
g_teams.cpp:	if( ent->r.client->team != TEAM_SPECTATOR && team != TEAM_SPECTATOR ) {
g_teams.cpp:		int64_t timeStamp = ent->r.client->teamstate.timeStamp;
g_teams.cpp:		memset( &ent->r.client->teamstate, 0, sizeof( ent->r.client->teamstate ) );
g_teams.cpp:		ent->r.client->teamstate.timeStamp = timeStamp;
g_teams.cpp:		memset( &ent->r.client->teamstate, 0, sizeof( ent->r.client->teamstate ) );
g_teams.cpp:		ent->r.client->teamstate.timeStamp = level.time;
g_teams.cpp:	if( ent->r.client->team == TEAM_SPECTATOR || team == TEAM_SPECTATOR ) {
g_teams.cpp:	ent->r.client->team = team;
g_teams.cpp:				G_PrintMsg( NULL, "%s joined the %s team.\n", ent->r.client->netname, GS_TeamName( ent->s.team ) );
g_teams.cpp:			G_PrintMsg( NULL, "%s joined the %s team.\n", ent->r.client->netname, GS_TeamName( ent->s.team ) );
g_teams.cpp:			G_PrintMsg( NULL, "%s joined the %s team.\n", ent->r.client->netname, GS_TeamName( ent->s.team ) );
g_trigger.cpp:		GS_TouchPushTrigger( &server_gs, &other->r.client->ps, &self->s );
g_trigger.cpp:	if( self->spawnflags & 1 && other->r.client->ps.pmove.pm_type != PM_SPECTATOR ) {
g_utils.cpp:						  who->r.client->ps.team == TEAM_SPECTATOR ? "SPEC" : "TEAM", who->r.client->netname, msg );
g_utils.cpp:				Com_Printf( "%s: %s\n", who->r.client->netname, msg );
g_utils.cpp:			if( !other->r.client || !other->r.inuse || !other->r.client->resp.chase.active ) {
g_utils.cpp:			if( other->r.client->resp.chase.target == ENTNUM( ent ) ) {
g_utils.cpp:		if( client->resp.eventsCurrent < client->resp.eventsHead ) {
g_utils.cpp:			client->ps.events[ i ] = client->resp.events[client->resp.eventsCurrent & MAX_CLIENT_EVENTS_MASK];
g_utils.cpp:			client->resp.eventsCurrent++;
g_utils.cpp:			client->ps.events[ i ] = { };
g_utils.cpp:	SyncEvent * event = &client->resp.events[client->resp.eventsHead & MAX_CLIENT_EVENTS_MASK];
g_utils.cpp:	client->resp.eventsHead++;
g_utils.cpp:		memset( client->resp.events, PSEV_NONE, sizeof( client->resp.events ) );
g_utils.cpp:		client->resp.eventsCurrent = client->resp.eventsHead = 0;
g_utils.cpp:		if( StrCaseEqual( e->r.client->netname, text ) ) {
g_utils.cpp:				if( playerTeam == TEAM_SPECTATOR && ent->r.client->resp.chase.active
g_utils.cpp:					&& ent->r.client->resp.chase.target > 0 ) {
g_utils.cpp:					playerTeam = game.edicts[ent->r.client->resp.chase.target].s.team;
g_weapon.cpp:		spreadness += ZoomSpreadness( self->r.client->ps.zoom_time, def );
g_weapon.cpp:	Vec2 spread = RandomSpreadPattern( self->r.client->ucmd.entropy, spreadness );
g_weapon.cpp:		owner->r.client->ps.weapon_state != WeaponState_FiringSmooth ) {
g_weapon.cpp:	float spreadness = def->zoom_spread * ( 1.0f - float( self->r.client->ps.zoom_time ) / float( ZOOMTIME ) );
g_weapon.cpp:		viewoffset.z += ent->r.client->ps.viewheight;
g_weapon.cpp:		timeDelta = ent->r.client->timeDelta;
g_weapon.cpp:		angles = ent->r.client->ps.viewangles;
g_weapon.cpp:		SyncPlayerState * ps = &other->r.client->ps;
g_weapon.cpp:	origin.z += ent->r.client->ps.viewheight;
g_weapon.cpp:	Vec3 angles = ent->r.client->ps.viewangles;
g_weapon.cpp:	int timeDelta = ent->r.client->timeDelta;
gt_bomb.cpp:	ClearInventory( &ent->r.client->ps );
gt_bomb.cpp:		if( carrier_ent->r.client->ps.pmove.crouch_time > 0 && level.time - bomb_state.bomb.action_time >= 1000 && Length( velocity ) < bomb_max_plant_speed ) {
gt_bomb.cpp:	G_PrintMsg( NULL, "%s defused the bomb!\n", PLAYERENT( bomb_state.defuser )->r.client->netname );
gt_bomb.cpp:	ent->r.client->ps.pmove.max_speed = -1;
gt_bomb.cpp:	ent->r.client->ps.pmove.features = ent->r.client->ps.pmove.features | PMFEAT_JUMP | PMFEAT_SPECIAL;
gt_bomb.cpp:	ent->r.client->ps.pmove.max_speed = 100;
gt_bomb.cpp:	ent->r.client->ps.pmove.features &= ~( PMFEAT_JUMP | PMFEAT_SPECIAL );
gt_bomb.cpp:	ent->r.client->ps.pmove.no_shooting_time = 5000;
gt_bomb.cpp:			client->ps.progress = 0;
gt_bomb.cpp:			client->ps.progress_type = BombProgress_Nothing;
gt_bomb.cpp:		client->ps.progress = percent;
gt_bomb.cpp:		client->ps.progress_type = type;
gt_bomb.cpp:	SetLoadout( ent, Info_ValueForKey( ent->r.client->userinfo, "cg_loadout" ), true );
gt_bomb.cpp:	client->ps.pmove.features |= PMFEAT_TEAMGHOST;
gt_bomb.cpp:		client->ps.can_change_loadout = new_team >= TEAM_ALPHA;
gt_bomb.cpp:		client->ps.can_change_loadout = !G_ISGHOSTING( ent ) && server_gs.gameState.round_state == RoundState_Countdown;
gt_bomb.cpp:		client->ps.carrying_bomb = false;
gt_bomb.cpp:		client->ps.can_plant = false;
gt_bomb.cpp:		carrier->r.client->ps.carrying_bomb = true;
gt_bomb.cpp:		carrier->r.client->ps.can_plant = bomb_state.carrier_can_plant_time >= level.time - 50;
gt_gladiator.cpp:			RoundAnnouncementPrint( temp( "{} is a true gladiator!", winner->r.client->netname ) );
gt_gladiator.cpp:					ent->r.client->ps.pmove.no_shooting_time = countdown_seconds * 1000;
gt_gladiator.cpp:			DynamicString vs_string( &temp, "{}", PLAYERENT( gladiator_state.round_challengers[ 0 ] )->r.client->netname );
gt_gladiator.cpp:				vs_string.append( temp( " vs. {}", PLAYERENT( player )->r.client->netname ) );
p_client.cpp:				Com_GGPrint( "\"{}\" \"{}\" {} {}", self->r.client->netname, attacker->r.client->netname, damage_type.encoded, wallbang ? 1 : 0 );
p_client.cpp:				Com_GGPrint( "\"{}\" suicide {}", self->r.client->netname, damage_type.encoded );
p_client.cpp:			Com_GGPrint( "\"{}\" suicide {}", self->r.client->netname, damage_type.encoded );
p_client.cpp:	client_snapreset_t resp_snap_backup = ent->r.client->resp.snap;
p_client.cpp:	ent->s.angles.y = ent->r.client->ps.viewangles.y = LookAtKillerYAW( ent, inflictor, attacker );
p_client.cpp:	ent->r.client->resp.snap = resp_snap_backup;
p_client.cpp:	ent->r.client->resp.snap.buttons = 0;
p_client.cpp:	client->level.last_activity = level.time;
p_client.cpp:	if( client->ps.pmove.pm_type != PM_NORMAL ) {
p_client.cpp:	if( client->level.last_activity && client->level.last_activity + ( g_inactivity_maxtime->number * 1000 ) < level.time ) {
p_client.cpp:		if( client->team >= TEAM_PLAYERS && client->team < GS_MAX_TEAMS ) {
p_client.cpp:			G_PrintMsg( NULL, "%s has been moved to spectator after %.1f seconds of inactivity\n", client->netname, g_inactivity_maxtime->number );
p_client.cpp:	return &ent->r.client->level.stats;
p_client.cpp:	memset( &ent->r.client->resp.snap, 0, sizeof( ent->r.client->resp.snap ) );
p_client.cpp:	memset( &ent->r.client->resp.chase, 0, sizeof( ent->r.client->resp.chase ) );
p_client.cpp:	ent->r.client->resp.old_waterlevel = 0;
p_client.cpp:	ent->r.client->resp.old_watertype = 0;
p_client.cpp:	ClearInventory( &ent->r.client->ps );
p_client.cpp:	if( self->r.client->team < 0 || self->r.client->team >= GS_MAX_TEAMS ) {
p_client.cpp:		self->r.client->team = TEAM_SPECTATOR;
p_client.cpp:	if( self->r.client->team == TEAM_SPECTATOR ) {
p_client.cpp:	memset( &client->resp, 0, sizeof( client->resp ) );
p_client.cpp:	memset( &client->ps, 0, sizeof( client->ps ) );
p_client.cpp:	client->resp.timeStamp = level.time;
p_client.cpp:	client->ps.playerNum = PLAYERNUM( self );
p_client.cpp:	self->s.team = client->team;
p_client.cpp:	client->ps.POVnum = ENTNUM( self );
p_client.cpp:	client->ps.pmove.max_speed = -1;
p_client.cpp:		client->ps.pmove.features = PMFEAT_DEFAULT;
p_client.cpp:	ClientUserinfoChanged( self, client->userinfo );
p_client.cpp:		client->ps.pmove.origin = spawn_origin;
p_client.cpp:		client->ps.viewangles = Vec3( self->s.angles );
p_client.cpp:	client->ps.pmove.delta_angles[ 0 ] = ANGLE2SHORT( client->ps.viewangles.x ) - client->ucmd.angles[ 0 ];
p_client.cpp:	client->ps.pmove.delta_angles[ 1 ] = ANGLE2SHORT( client->ps.viewangles.y ) - client->ucmd.angles[ 1 ];
p_client.cpp:	client->ps.pmove.delta_angles[ 2 ] = ANGLE2SHORT( client->ps.viewangles.z ) - client->ucmd.angles[ 2 ];
p_client.cpp:	if( player->r.client->ps.pmove.pm_type > PM_SPECTATOR ) {
p_client.cpp:	Vec3 velocity = client->old_pmove.velocity;
p_client.cpp:	client->ps.pmove.velocity = FromQFAxis( axis, AXIS_FORWARD ) * ( speed );
p_client.cpp:	client->ps.viewangles = dest->s.angles;
p_client.cpp:	client->ps.pmove.origin = dest->s.origin;
p_client.cpp:	client->ps.pmove.delta_angles[ 0 ] = ANGLE2SHORT( client->ps.viewangles.x ) - client->ucmd.angles[ 0 ];
p_client.cpp:	client->ps.pmove.delta_angles[ 1 ] = ANGLE2SHORT( client->ps.viewangles.y ) - client->ucmd.angles[ 1 ];
p_client.cpp:	client->ps.pmove.delta_angles[ 2 ] = ANGLE2SHORT( client->ps.viewangles.z ) - client->ucmd.angles[ 2 ];
p_client.cpp:	client->ps.pmove.pm_flags |= PMF_TIME_TELEPORT;
p_client.cpp:	client->ps.pmove.pm_time = 1; // force the minimum no control delay
p_client.cpp:	player->s.angles = client->ps.viewangles;
p_client.cpp:	player->s.origin = client->ps.pmove.origin;
p_client.cpp:	player->olds.origin = client->ps.pmove.origin;
p_client.cpp:	player->velocity = client->ps.pmove.velocity;
p_client.cpp:	memset( &client->ucmd, 0, sizeof( client->ucmd ) );
p_client.cpp:	memset( &client->level, 0, sizeof( client->level ) );
p_client.cpp:	client->level.timeStamp = level.time;
p_client.cpp:	G_PrintMsg( NULL, "%s entered the game\n", client->netname );
p_client.cpp:	client->connecting = false;
p_client.cpp:			if( !Q_stricmp( name, other->r.client->netname ) ) {
p_client.cpp:	Q_strncpyz( ent->r.client->netname, name, sizeof( ent->r.client->netname ) );
p_client.cpp:	PF_ConfigString( CS_PLAYERINFOS + playerNum, client->netname );
p_client.cpp:	ent->r.client->ps.playerNum = PLAYERNUM( ent );
p_client.cpp:	ent->r.client->connecting = true;
p_client.cpp:	ent->r.client->team = TEAM_SPECTATOR;
p_client.cpp:		snprintf( message, sizeof( message ), "%s connected", ent->r.client->netname );
p_client.cpp:		Com_Printf( "%s connected from %s\n", ent->r.client->netname, Info_ValueForKey( userinfo, "ip" ) );
p_client.cpp:		G_PrintMsg( NULL, "%s disconnected\n", ent->r.client->netname );
p_client.cpp:		G_PrintMsg( NULL, "%s disconnected (%s)\n", ent->r.client->netname, reason );
p_client.cpp:	ent->r.client->ps.playerNum = PLAYERNUM( ent );
p_client.cpp:	start.z += ent->r.client->ps.viewheight;
p_client.cpp:	event->s.origin2 = ent->r.client->ps.viewangles;
p_client.cpp:	SyncPlayerState * ps = &ent->r.client->ps;
p_client.cpp:	SyncPlayerState * ps = &ent->r.client->ps;
p_client.cpp:	client->ps.POVnum = ENTNUM( ent );
p_client.cpp:	client->ps.playerNum = PLAYERNUM( ent );
p_client.cpp:		client->timeDelta = 0;
p_client.cpp:		i = client->timeDeltasHead - 6;
p_client.cpp:		for( count = 0, delta = 0; i < client->timeDeltasHead; i++ ) {
p_client.cpp:			if( client->timeDeltas[i & G_MAX_TIME_DELTAS_MASK] < 0 ) {
p_client.cpp:				delta += client->timeDeltas[i & G_MAX_TIME_DELTAS_MASK];
p_client.cpp:			client->timeDelta = timeDelta;
p_client.cpp:			client->timeDelta = ( delta + timeDelta ) * 0.5;
p_client.cpp:		client->timeDeltas[client->timeDeltasHead & G_MAX_TIME_DELTAS_MASK] = timeDelta;
p_client.cpp:		client->timeDeltasHead++;
p_client.cpp:	client->timeDelta = Clamp( -g_antilag_maxtimedelta->integer, client->timeDelta, 0 );
p_client.cpp:		client->ucmd.angles[PITCH] != ucmd->angles[PITCH] || client->ucmd.angles[YAW] != ucmd->angles[YAW] ) {
p_client.cpp:	client->ucmd = *ucmd;
p_client.cpp:	client->ps.pmove.origin = ent->s.origin;
p_client.cpp:	client->ps.pmove.velocity = ent->velocity;
p_client.cpp:	client->ps.viewangles = ent->s.angles;
p_client.cpp:		client->ps.pmove.pm_type = PM_FREEZE;
p_client.cpp:		client->ps.pmove.pm_type = PM_SPECTATOR;
p_client.cpp:		client->ps.pmove.pm_type = PM_NORMAL;
p_client.cpp:	pm.playerState = &client->ps;
p_client.cpp:	client->old_pmove = client->ps.pmove;
p_client.cpp:	ent->s.origin = client->ps.pmove.origin;
p_client.cpp:	ent->velocity = client->ps.pmove.velocity;
p_client.cpp:	ent->s.angles = client->ps.viewangles;
p_client.cpp:	ent->viewheight = client->ps.viewheight;
p_client.cpp:	UpdateWeapons( &server_gs, &client->ps, *ucmd, client->timeDelta );
p_client.cpp:	client->resp.snap.buttons |= ucmd->buttons;
p_client.cpp:	ent->r.client->ps.POVnum = ENTNUM( ent ); // set self
p_client.cpp:		bool clicked = level.time > ent->deathTimeStamp + min_delay && ( ent->r.client->resp.snap.buttons & BUTTON_ATTACK );
p_hud.cpp:	Vec3 vieworg = self->r.client->ps.pmove.origin;
p_hud.cpp:	vieworg.z += self->r.client->ps.viewheight;
p_hud.cpp:	AngleVectors( self->r.client->ps.viewangles, &viewforward, NULL, NULL );
p_hud.cpp:	SyncPlayerState * ps = &client->ps;
p_view.cpp:	client->ps.viewangles.z = 0;
p_view.cpp:	client->ps.viewangles.x = 0;
p_view.cpp:			client->ps.viewangles.y = LookAtKillerYAW( ent, NULL, body->enemy );
p_view.cpp:	client->ps.pmove.origin = ent->s.origin;
p_view.cpp:	client->ps.viewangles = ent->s.angles;
p_view.cpp:	client->ps.pmove.velocity = Vec3( 0.0f );
p_view.cpp:	float frac = (float)damage / ( damage + client->resp.snap.damageTaken );
p_view.cpp:	client->resp.snap.damageTakenDir = Lerp( client->resp.snap.damageTakenDir, frac, dir );
p_view.cpp:	client->resp.snap.damageTaken += damage;
p_view.cpp:	if( ent->r.client->resp.snap.damageTaken ) {
p_view.cpp:		int damage = ent->r.client->resp.snap.damageTaken;
p_view.cpp:		u64 parm = DirToU64( ent->r.client->resp.snap.damageTakenDir );
p_view.cpp:	old_waterlevel = ent->r.client->resp.old_waterlevel;
p_view.cpp:	old_watertype = ent->r.client->resp.old_watertype;
p_view.cpp:	ent->r.client->resp.old_waterlevel = waterlevel;
p_view.cpp:	ent->r.client->resp.old_watertype = watertype;
p_view.cpp:		client->ps.pmove.delta_angles[i] = ANGLE2SHORT( client->ps.viewangles[i] ) - client->ucmd.angles[i];
